/// Summarization strategy for context compaction
///
/// This strategy identifies sequences of assistant messages in a conversation
/// and replaces them with a single summarized message, preserving user messages
/// and maintaining conversation continuity while reducing token usage.
use anyhow::Result;
use tracing::debug;

use super::strategy::CompactionImpact;
use super::CompactionStrategy;
use crate::services::{Services, TemplateService};
use crate::{Compact, Context, ContextMessage};

/// Compaction strategy that identifies sequences of messages and replaces them
/// with a summary generated by an LLM
pub struct SummarizationStrategy;

impl CompactionStrategy for SummarizationStrategy {
    fn id(&self) -> &'static str {
        "summarization"
    }

    fn is_applicable(&self, compact: &Compact, context: &Context) -> bool {
        let preserve_last_n = compact.retention_window;
        super::find_sequence(context, preserve_last_n).is_some()
    }
}

impl SummarizationStrategy {
    /// Compacts the context by identifying sequences of messages and replacing
    /// them with a summary
    pub async fn compact<S: Services>(
        &self,
        compact: &Compact,
        context: Context,
        services: &S,
    ) -> Result<(Context, CompactionImpact)> {
        let preserve_last_n = compact.retention_window;
        let original_message_count = context.messages.len();

        // Find a sequence of messages to summarize
        if let Some((start, end)) = super::find_sequence(&context, preserve_last_n) {
            debug!(
                strategy = self.id(),
                start, end, "Found compressible sequence of messages"
            );

            let mut new_context = context.clone();
            let summary_text = services
                .template_service()
                .render_summarization(compact, &context)
                .await?;

            // Create a new message containing the summary
            let summary_msg = ContextMessage::assistant(summary_text, None);

            // Replace the sequence of messages with the summary
            new_context.messages.splice(start..=end, [summary_msg]);

            let impact = CompactionImpact::new(
                original_message_count,
                new_context.messages.len(),
                None, // We don't have token counts available
            );

            Ok((new_context, impact))
        } else {
            // No sequence found, return the context unchanged with zero impact
            let impact =
                CompactionImpact::new(original_message_count, original_message_count, Some(0));
            Ok((context, impact))
        }
    }
}
