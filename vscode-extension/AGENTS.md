# Agent Guidelines

This document contains guidelines and best practices for AI agents working with this codebase.

## Component Library - shadcn/ui

### Critical Rule: DO NOT MODIFY GENERATED COMPONENTS

The `webview-ui/src/components/ui/` directory contains **generated shadcn/ui components**.

**⛔ NEVER modify files in `webview-ui/src/components/ui/`**

These components are:
- Generated by the shadcn CLI
- Considered external dependencies
- Updated through `npx shadcn@latest add <component>`
- Maintained by the shadcn/ui project

### If Customization is Needed

Instead of modifying shadcn components directly, use these approaches:

#### 1. Wrapper Components
Create wrapper components in the presentation layer:

```typescript
// ✅ CORRECT: Create a wrapper component
// webview-ui/src/presentation/components/chat/CustomButton.tsx
import { Button } from "@/components/ui/button"

export const CustomButton = ({ children, ...props }) => {
  return (
    <Button className="custom-styles" {...props}>
      {children}
    </Button>
  )
}
```

```typescript
// ❌ WRONG: Modifying shadcn component directly
// webview-ui/src/components/ui/button.tsx
export const Button = ({ children }) => {
  return <button className="my-custom-styles">{children}</button>
}
```

#### 2. Tailwind Classes
Use Tailwind utility classes for styling:

```typescript
// ✅ CORRECT: Apply Tailwind classes when using the component
import { Button } from "@/components/ui/button"

<Button className="bg-blue-600 hover:bg-blue-700">
  Click me
</Button>
```

#### 3. Component Variants
Use the built-in variant system:

```typescript
// ✅ CORRECT: Use variants provided by shadcn
import { Button } from "@/components/ui/button"

<Button variant="outline" size="sm">
  Click me
</Button>
```

#### 4. Custom Variants
Create custom variants using `class-variance-authority`:

```typescript
// ✅ CORRECT: Define custom variants in a separate file
// webview-ui/src/lib/variants.ts
import { cva } from "class-variance-authority"

export const customButtonVariants = cva(
  "base-styles",
  {
    variants: {
      intent: {
        primary: "bg-primary",
        secondary: "bg-secondary",
      },
    },
  }
)
```

### When to Update shadcn Components

Only update shadcn components through the official CLI:

```bash
# Add a new component
npx shadcn@latest add <component-name>

# Update an existing component (if shadcn releases an update)
npx shadcn@latest add <component-name> --overwrite
```

**Note:** Always review changes before committing when updating via CLI.

## Project Architecture

### Onion Architecture Layers

This project follows onion architecture. Respect layer boundaries:

1. **Domain** (`webview-ui/src/domain/`)
   - Core business logic
   - Domain models (Effect Schema)
   - Domain services (pure functions)
   - No dependencies on other layers

2. **Application** (`webview-ui/src/application/`)
   - Use cases
   - Application state management
   - Depends on: Domain

3. **Infrastructure** (`webview-ui/src/infrastructure/`)
   - External integrations (RPC, VSCode API)
   - Concrete implementations
   - Depends on: Domain, Application

4. **Presentation** (`webview-ui/src/presentation/`)
   - React components
   - UI logic and hooks
   - Depends on: Domain, Application, Infrastructure

### Component Directory Rules

**Generated (DO NOT MODIFY):**
- `webview-ui/src/components/ui/` - shadcn/ui components

**Application Components (MODIFY AS NEEDED):**
- `webview-ui/src/presentation/components/` - Application-specific React components
- `webview-ui/src/lib/` - Utility functions and custom variants

## Effect-TS Integration

This project uses Effect-TS for state management and side effects.

### State Management Pattern

```typescript
// ✅ CORRECT: Use Effect-TS hooks in presentation layer
import { useChatState } from './presentation/hooks/useChatStateSimple'

function MyComponent() {
  const chatState = useChatState()
  // Use state...
}
```

### Side Effects

```typescript
// ✅ CORRECT: Use Effect for side effects
import { Effect } from "effect"

const sendMessage = (text: string) =>
  Effect.gen(function* () {
    const result = yield* rpcService.request("sendMessage", { text })
    return result
  })
```

## VSCode Extension Guidelines

### Webview Communication

Communication between extension and webview uses JSON-RPC over `postMessage`:

```typescript
// Extension → Webview
webviewProvider.postMessage({ 
  jsonrpc: "2.0", 
  id: "123", 
  result: data 
})

// Webview → Extension
vscode.postMessage({ 
  jsonrpc: "2.0", 
  method: "sendMessage", 
  params: {...} 
})
```

**Important:** VSCode webviews use `window.addEventListener('message', ...)` to receive messages.

### Content Security Policy (CSP)

The webview has strict CSP. When adding new resources:
- Scripts must use nonce
- Styles can be inline or from same origin
- Images from same origin or data URIs only

## Testing

### Component Testing

```typescript
// ✅ CORRECT: Test presentation components with React Testing Library
import { render, screen } from '@testing-library/react'
import { MessageItem } from './MessageItem'

test('renders message content', () => {
  const message = { role: 'user', content: 'Hello' }
  render(<MessageItem message={message} />)
  expect(screen.getByText('Hello')).toBeInTheDocument()
})
```

### Effect-TS Testing

```typescript
// ✅ CORRECT: Test Effect-based services
import { Effect } from "effect"

test('message validation', async () => {
  const service = new MessageValidationService()
  const result = await Effect.runPromise(service.validate(message))
  expect(result).toBe(true)
})
```

## Code Style

### Imports

Use path aliases for clean imports:

```typescript
// ✅ CORRECT: Use path aliases
import { Message } from "@domain/models"
import { Button } from "@/components/ui/button"
import { useChatState } from "@presentation/hooks/useChatStateSimple"

// ❌ WRONG: Relative imports for cross-layer dependencies
import { Message } from "../../../domain/models"
```

### Component Structure

```typescript
// ✅ CORRECT: Component structure
import React from "react"
import { Button } from "@/components/ui/button"
import { Message } from "@domain/models"

interface MessageItemProps {
  message: Message
  onDelete?: () => void
}

/// MessageItem displays a single chat message
export const MessageItem: React.FC<MessageItemProps> = ({ 
  message, 
  onDelete 
}) => {
  return (
    <div>
      {/* Component JSX */}
    </div>
  )
}
```

## Build and Development

### Development Workflow

```bash
# Watch extension code
npm run watch

# Watch webview (in another terminal)
npm run watch:webview
```

### Production Build

```bash
# Build everything
npm run vscode:prepublish
```

### Adding shadcn Components

```bash
# Navigate to webview-ui directory
cd webview-ui

# Add component
npx shadcn@latest add <component-name>

# Commit the generated files
git add src/components/ui/<component-name>.tsx
git commit -m "Add shadcn <component-name> component"
```

## Common Mistakes to Avoid

### ❌ Modifying shadcn Components

```typescript
// ❌ NEVER DO THIS
// File: webview-ui/src/components/ui/button.tsx
export const Button = ({ children, className }) => {
  return (
    <button className={cn("my-custom-class", className)}>
      {children}
    </button>
  )
}
```

### ❌ Breaking Layer Boundaries

```typescript
// ❌ WRONG: Domain depending on Infrastructure
// File: webview-ui/src/domain/services/MessageService.ts
import { VscodeRpcService } from "@infrastructure/rpc/VscodeRpcService"

export class MessageService {
  constructor(private rpc: VscodeRpcService) {} // Domain should not know about infrastructure
}
```

### ❌ Direct State Mutation

```typescript
// ❌ WRONG: Mutating state directly
chatState.messages.push(newMessage)

// ✅ CORRECT: Use immutable updates
const newState = {
  ...chatState,
  messages: [...chatState.messages, newMessage]
}
```

### ❌ Mixing Concerns

```typescript
// ❌ WRONG: Business logic in presentation component
export const MessageItem = ({ message }) => {
  // Don't validate in presentation layer
  const isValid = message.content.length > 0 && message.role !== undefined
  
  if (!isValid) return null
  
  return <div>{message.content}</div>
}

// ✅ CORRECT: Validation in domain layer
// Domain service handles validation
// Presentation component only renders
```

## Summary of Key Rules

1. **NEVER modify `webview-ui/src/components/ui/`** - These are generated shadcn components
2. **Respect layer boundaries** - Follow onion architecture principles
3. **Use Effect-TS** - For state management and side effects
4. **Use path aliases** - Keep imports clean and maintainable
5. **Wrap, don't modify** - Customize shadcn components through wrappers
6. **Test presentation components** - Use React Testing Library
7. **Document with JSDoc** - Add `///` comments for all public APIs

## Questions?

When in doubt:
- Check existing code for patterns
- Review `webview-ui/ARCHITECTURE.md` for architecture details
- Check this file for component and styling guidelines
- Refer to [shadcn/ui docs](https://ui.shadcn.com/) for component usage
- Refer to [Effect-TS docs](https://effect.website) for Effect patterns
