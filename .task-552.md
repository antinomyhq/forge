# Task Plan for Issue #552: Refactor `println!` calls to use Infrastructure Trait

## Issue Details

**Title:** refactor: Migrate all the `println`

**Description:**
- We have plenty of tools that have `println` inside them.
- We need to refactor that out and expose that API via the Infrastructure trait.
- All tools should use infra to print text on the console, instead of printing using `println!`
- The infra implementation should use println.
- The design inspiration should come from all the file operations that we perform currently via the infrastructure layer.

## Plan

This refactoring will introduce a new console output service in the infrastructure layer, removing direct dependencies on `println!` and `eprintln!` from the codebase. This will improve testability, maintainability, and provide a consistent approach to console output, following the established patterns for infrastructure services in the forge project.

### Key Design Decisions

1. Create a new `ConsoleService` trait in its own file `forge_app/src/console.rs`
2. Add an associated type to the `Infrastructure` trait for the console service
3. Implement the console service in `forge_infra/src/console.rs`
4. Refactor all tools to use the infrastructure's console service instead of direct `println!` and `eprintln!` calls
5. Ensure proper error handling and formatting capabilities in the new console service
6. Provide a mock implementation for testing

### Requirements

1. ✅ All direct `println!` and `eprintln!` calls should be removed from tools and replaced with the infrastructure console service
2. ✅ The infrastructure implementation should internally use `println!` and `eprintln!`
3. ✅ The design should follow the pattern established for other infrastructure services
4. ✅ Implementation should maintain the current functionality (output formatting, colors, etc.)
5. ✅ Integration tests should be updated to support the new abstraction
6. ✅ Maintain backward compatibility where possible
7. ✅ Documentation for the new service should be added

## Implementation Steps

### 1. Define the Console Service Trait

- [ ] Create new file `forge_app/src/console.rs` for the `ConsoleService` trait
- [ ] Define the trait with methods for standard output and error output
- [ ] Include methods for both plain text and formatted output
- [ ] Export the trait in `forge_app/src/lib.rs`
- [ ] Add support for handling colors and formatting

### 2. Update Infrastructure Trait

- [ ] Add associated type `ConsoleService` to the `Infrastructure` trait in `forge_app/src/lib.rs`
- [ ] Add method `console_service(&self) -> &Self::ConsoleService` to the trait
- [ ] Update existing documentation to include the new service

### 3. Implement Console Service

- [ ] Create `forge_infra/src/console.rs` for the `ForgeConsoleService` implementation
- [ ] Implement the `ConsoleService` trait with methods that delegate to `println!` and `eprintln!` respectively
- [ ] Add appropriate error handling and logging
- [ ] Handle formatting and colored output properly
- [ ] Update `forge_infra/src/lib.rs` to export the new service

### 4. Update ForgeInfra to Include ConsoleService

- [ ] Modify `forge_infra/src/infra.rs` to add a new field for console service
- [ ] Update the `ForgeInfra::new` method to initialize the console service
- [ ] Implement the `console_service()` method for the `Infrastructure` trait
- [ ] Update `impl Infrastructure for ForgeInfra` to include the new associated type

### 5. Refactor Direct println! and eprintln! Usage

- [ ] Identify all locations using `println!` and `eprintln!` in the codebase
- [ ] Replace direct console output with calls to the infrastructure console service
- [ ] Update imports in affected files
- [ ] Ensure formatting and output behavior remains consistent
- [ ] Pay special attention to tools that use colored or specially formatted output
- [ ] Update any tests that rely on console output

### 6. Create Testing Infrastructure

- [ ] Create a mock implementation of `ConsoleService` for testing
- [ ] Update or create unit tests for components that use console output
- [ ] Create specific tests for the console service itself

### 7. Documentation and Examples

- [ ] Document the new console service in rustdoc comments
- [ ] Add examples of usage in documentation
- [ ] Update developer guides if necessary
- [ ] Consider adding a helper macro to simplify migration and usage

## File Changes Required

1. **New Files**:
   - `forge_app/src/console.rs` - Definition of the console service trait
   - `forge_infra/src/console.rs` - Implementation of the console service

2. **Modified Files**:
   - `forge_app/src/lib.rs` - Export console service trait and update Infrastructure trait
   - `forge_infra/src/infra.rs` - Update infrastructure implementation to include console service
   - `forge_infra/src/lib.rs` - Export console service implementation
   - Multiple tool files that currently use `println!` or `eprintln!` directly

## Verification Criteria

- [ ] All direct `println!` and `eprintln!` calls should be removed from tools
- [ ] Console output should remain functionally identical including formatting and colors
- [ ] All tests should pass with the new implementation
- [ ] Code review should confirm that the implementation follows the established pattern for infrastructure services
- [ ] Manual verification of tools that heavily use console output to ensure behavior is preserved
- [ ] No regression in error reporting or logging

## Implementation Notes

### Console Service Trait Design

```rust
/// Service for outputting text to the console
pub trait ConsoleService: Send + Sync + 'static {
    /// Print a message to the console standard output
    fn stdout(&self, message: &str);
    
    /// Print a formatted message to the console standard output
    fn stdout_fmt(&self, args: std::fmt::Arguments<'_>);
    
    /// Print a message to the console error output
    fn stderr(&self, message: &str);
    
    /// Print a formatted message to the console error output
    fn stderr_fmt(&self, args: std::fmt::Arguments<'_>);
    
    /// Print a message with specified color to standard output
    fn stdout_colored(&self, message: &str, color: ConsoleColor);
    
    /// Print a message with specified color to error output
    fn stderr_colored(&self, message: &str, color: ConsoleColor);
}

/// Represents colors that can be used for console output
pub enum ConsoleColor {
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    Default,
}
```

### ForgeConsoleService Implementation

```rust
use std::fmt;
use forge_app::ConsoleService;

#[derive(Clone)]
pub struct ForgeConsoleService;

impl ForgeConsoleService {
    pub fn new() -> Self {
        Self
    }
}

impl ConsoleService for ForgeConsoleService {
    fn stdout(&self, message: &str) {
        println!("{}", message);
    }
    
    fn stdout_fmt(&self, args: fmt::Arguments<'_>) {
        println!("{}", args);
    }
    
    fn stderr(&self, message: &str) {
        eprintln!("{}", message);
    }
    
    fn stderr_fmt(&self, args: fmt::Arguments<'_>) {
        eprintln!("{}", args);
    }
    
    fn stdout_colored(&self, message: &str, color: ConsoleColor) {
        // Implementation using an appropriate terminal coloring library
        // For example, using colored, ansi_term, or termcolor crates
        let colored_message = apply_color(message, color);
        println!("{}", colored_message);
    }
    
    fn stderr_colored(&self, message: &str, color: ConsoleColor) {
        // Implementation using an appropriate terminal coloring library
        let colored_message = apply_color(message, color);
        eprintln!("{}", colored_message);
    }
}

// Helper function to apply terminal colors
fn apply_color(message: &str, color: ConsoleColor) -> String {
    // Implementation will depend on which coloring library is used in the project
    // This is a simplified example
    match color {
        ConsoleColor::Red => format!("\x1b[31m{}\x1b[0m", message),
        ConsoleColor::Green => format!("\x1b[32m{}\x1b[0m", message),
        // ... other colors
        ConsoleColor::Default => message.to_string(),
    }
}
```

### Integration with Infrastructure

```rust
// In forge_app/src/lib.rs
pub trait Infrastructure: Send + Sync + Clone + 'static {
    type EmbeddingService: EmbeddingService;
    type EnvironmentService: EnvironmentService;
    type FsMetaService: FsMetaService;
    type FsReadService: FsReadService;
    type FsRemoveService: FileRemoveService;
    type FsSnapshotService: FsSnapshotService;
    type FsWriteService: FsWriteService;
    type VectorIndex: VectorIndex<Suggestion>;
    type FsCreateDirsService: FsCreateDirsService;
    type ConsoleService: ConsoleService; // New associated type
    
    // ... existing methods
    
    fn console_service(&self) -> &Self::ConsoleService; // New accessor method
}

// In forge_infra/src/infra.rs
pub struct ForgeInfra {
    // ... existing fields
    console_service: Arc<ForgeConsoleService>,
}

impl ForgeInfra {
    pub fn new(restricted: bool) -> Self {
        // ... existing initialization
        Self {
            // ... existing fields
            console_service: Arc::new(ForgeConsoleService::new()),
        }
    }
}

impl Infrastructure for ForgeInfra {
    // ... existing associated types
    type ConsoleService = ForgeConsoleService;
    
    // ... existing methods
    
    fn console_service(&self) -> &Self::ConsoleService {
        &self.console_service
    }
}
```

### Helper Macro for Convenience

```rust
// Optional helper macro for easier migration
#[macro_export]
macro_rules! infra_println {
    ($infra:expr, $($arg:tt)*) => {
        $infra.console_service().stdout_fmt(format_args!($($arg)*))
    }
}

#[macro_export]
macro_rules! infra_eprintln {
    ($infra:expr, $($arg:tt)*) => {
        $infra.console_service().stderr_fmt(format_args!($($arg)*))
    }
}
```

### Mock Implementation for Testing

```rust
// In a test module
use std::cell::RefCell;
use std::fmt;
use std::rc::Rc;

#[derive(Clone, Default)]
pub struct MockConsoleService {
    stdout_messages: Rc<RefCell<Vec<String>>>,
    stderr_messages: Rc<RefCell<Vec<String>>>,
}

impl MockConsoleService {
    pub fn new() -> Self {
        Self {
            stdout_messages: Rc::new(RefCell::new(Vec::new())),
            stderr_messages: Rc::new(RefCell::new(Vec::new())),
        }
    }
    
    pub fn get_stdout_messages(&self) -> Vec<String> {
        self.stdout_messages.borrow().clone()
    }
    
    pub fn get_stderr_messages(&self) -> Vec<String> {
        self.stderr_messages.borrow().clone()
    }
}

impl ConsoleService for MockConsoleService {
    fn stdout(&self, message: &str) {
        self.stdout_messages.borrow_mut().push(message.to_string());
    }
    
    // ... other method implementations that record messages
}
```

This mock implementation captures the output for verification in tests rather than printing to the console, providing a way to test components that use the console service.