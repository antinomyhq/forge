diff --git a/src/main.rs b/src/main.rs
new file mode 100644
index 0000000..fd396b3
--- /dev/null
+++ b/src/main.rs
@@ -0,0 +1,64 @@
+use std::env;
+use std::process;
+
+mod task;
+mod task_manager;
+
+use task_manager::TaskManager;
+
+fn main() {
+    let args: Vec<String> = env::args().collect();
+    
+    if args.len() < 2 {
+        eprintln!("Usage: todo <command> [arguments]");
+        process::exit(1);
+    }
+    
+    let command = &args[1];
+    let mut task_manager = TaskManager::new();
+    
+    match command.as_str() {
+        "add" => {
+            if args.len() < 3 {
+                eprintln!("Error: Task title is required");
+                process::exit(1);
+            }
+            
+            // Join all remaining arguments as the task title
+            let title = args[2..].join(" ");
+            
+            // Validate the title is not empty
+            if title.trim().is_empty() {
+                eprintln!("Error: Task title cannot be empty");
+                process::exit(1);
+            }
+            
+            // Add the task
+            match task_manager.add_task(&title) {
+                Ok(task) => {
+                    println!("Task added: {}. {}", task.id, task.title);
+                }
+                Err(e) => {
+                    eprintln!("Error adding task: {}", e);
+                    process::exit(1);
+                }
+            }
+        }
+        _ => {
+            eprintln!("Unknown command: {}", command);
+            eprintln!("Supported commands: add");
+            process::exit(1);
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    
+    #[test]
+    fn test_command_parsing() {
+        // Test implementation details
+        assert!(true);
+    }
+}
+
diff --git a/src/task.rs b/src/task.rs
new file mode 100644
index 0000000..6e64693
--- /dev/null
--- /dev/null
+++ b/src/task.rs
@@ -0,0 +1,25 @@
+#[derive(Debug, Clone, PartialEq)]
+pub struct Task {
+    pub id: u32,
+    pub title: String,
+}
+
+impl Task {
+    pub fn new(id: u32, title: &str) -> Self {
+        Task {
+            id,
+            title: title.to_string(),
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    
+    #[test]
+    fn test_task_creation() {
+        let task = Task::new(1, "Test task");
+        assert_eq!(task.id, 1);
+        assert_eq!(task.title, "Test task");
+    }
+}
+
diff --git a/src/task_manager.rs b/src/task_manager.rs
new file mode 100644
index 0000000..2dfec80
--- /dev/null
+++ b/src/task_manager.rs
@@ -0,0 +1,44 @@
+use crate::task::Task;
+use std::error::Error;
+use std::fmt;
+
+#[derive(Debug)]
+pub struct TaskError(String);
+
+impl fmt::Display for TaskError {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        write!(f, "{}", self.0)
+    }
+}
+
+impl Error for TaskError {}
+
+pub struct TaskManager {
+    tasks: Vec<Task>,
+    next_id: u32,
+}
+
+impl TaskManager {
+    pub fn new() -> Self {
+        TaskManager {
+            tasks: Vec::new(),
+            next_id: 1,
+        }
+    }
+    
+    pub fn add_task(&mut self, title: &str) -> Result<Task, TaskError> {
+        // Validate title
+        if title.trim().is_empty() {
+            return Err(TaskError("Task title cannot be empty".to_string()));
+        }
+        
+        let task = Task::new(self.next_id, title);
+        self.tasks.push(task.clone());
+        self.next_id += 1;
+        
+        Ok(task)
+    }
+    
+    pub fn get_tasks(&self) -> &Vec<Task> {
+        &self.tasks
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    
+    #[test]
+    fn test_add_task() {
+        let mut manager = TaskManager::new();
+        let task = manager.add_task("Test task").unwrap();
+        
+        assert_eq!(task.id, 1);
+        assert_eq!(task.title, "Test task");
+        assert_eq!(manager.get_tasks().len(), 1);
+    }
+    
+    #[test]
+    fn test_add_multiple_tasks() {
+        let mut manager = TaskManager::new();
+        let task1 = manager.add_task("Task 1").unwrap();
+        let task2 = manager.add_task("Task 2").unwrap();
+        
+        assert_eq!(task1.id, 1);
+        assert_eq!(task2.id, 2);
+        assert_eq!(manager.get_tasks().len(), 2);
+    }
+    
+    #[test]
+    fn test_empty_title_validation() {
+        let mut manager = TaskManager::new();
+        let result = manager.add_task("");
+        
+        assert!(result.is_err());
+    }
+    
+    #[test]
+    fn test_whitespace_title_validation() {
+        let mut manager = TaskManager::new();
+        let result = manager.add_task("   ");
+        
+        assert!(result.is_err());
+    }
+} 